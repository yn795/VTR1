<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>mp4box.js で動画結合</title>

  <!-- mp4box.js をCDNから読み込み（FFmpegではなく、MP4解析用ライブラリ） -->
  <script src="https://unpkg.com/mp4box/dist/mp4box.all.min.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0; 
      padding: 20px;
      background: #f9f9f9;
    }
    h1, h2 {
      text-align: center;
      color: #333;
    }
    .container {
      max-width: 800px;
      margin: auto;
    }
    input[type="file"] {
      width: 100%;
      padding: 10px;
      margin-top: 10px;
    }
    button {
      width: 100%;
      padding: 15px;
      font-size: 18px;
      margin: 10px 0;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
    }
    button:disabled {
      background-color: #aaa;
      cursor: not-allowed;
    }
    #status {
      text-align: center;
      margin: 20px 0;
      font-weight: bold;
      color: #555;
    }
    video {
      width: 100%;
      height: auto;
      margin-top: 20px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    #downloadLink {
      display: none;
      margin-top: 20px;
      text-align: center;
    }
    #downloadLink button {
      background-color: #2196F3;
    }
    @media (max-width: 600px) {
      button {
        font-size: 16px;
        padding: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>複数動画ファイルの結合（mp4box.js）</h1>
    <h2>ブラウザで再エンコードなしに統合</h2>

    <!-- ファイル入力＆実行ボタン -->
    <input type="file" id="videoFiles" accept="video/mp4" multiple />
    <button id="mergeButton">動画を結合</button>

    <!-- ステータス表示 -->
    <div id="status">準備完了</div>

    <!-- 結合後プレビュー -->
    <video id="mergedVideo" controls></video>

    <!-- ダウンロードボタン -->
    <div id="downloadLink">
      <button id="downloadBtn">結合動画をダウンロード</button>
    </div>
  </div>

  <script>
    const mergeButton = document.getElementById("mergeButton");
    const statusText = document.getElementById("status");
    const mergedVideo = document.getElementById("mergedVideo");
    const downloadLinkDiv = document.getElementById("downloadLink");
    const downloadBtn = document.getElementById("downloadBtn");

    mergeButton.addEventListener("click", async () => {
      const files = document.getElementById("videoFiles").files;
      if (files.length < 2) {
        alert("2つ以上の動画ファイルを選択してください。");
        return;
      }

      // 一時的にボタンを無効化
      mergeButton.disabled = true;
      statusText.textContent = "動画を解析中...";

      try {
        // --------------------------------------------------------
        // 1. それぞれの動画を mp4box.js でパースし、「トラック情報」を取得
        // --------------------------------------------------------
        // 同じコーデック＆解像度でないと、結合しても正常に再生されない可能性あり
        let tracks = [];
        let initializationSegments = [];
        let totalDuration = 0;

        for (let i = 0; i < files.length; i++) {
          const arrayBuffer = await files[i].arrayBuffer();
          const mp4boxfile = MP4Box.createFile();

          // 読み込み完了を待つ Promise
          await new Promise((resolve, reject) => {
            mp4boxfile.onReady = (info) => {
              // MP4のトラック情報をここで取得
              tracks.push(...info.tracks);
              resolve();
            };
            mp4boxfile.onError = (e) => {
              reject(e);
            };

            // mp4box.js に読み込ませる
            mp4boxfile.appendBuffer(arrayBuffer);
            mp4boxfile.flush();
          });

          // 再度 createFile しないと二重にトラックが追加されるため、
          // 実データの切り出し用にもう一個 new する
          const mp4boxfile2 = MP4Box.createFile();

          // 結合後に使う「初期化セグメント」を作成する
          const initSegs = {};
          mp4boxfile2.onReady = (info) => {
            for (const track of info.tracks) {
              const initSeg = mp4boxfile2.initializeSegmentation(track.id, track.timescale, null);
              initSegs[track.id] = initSeg;
            }
          };
          mp4boxfile2.appendBuffer(arrayBuffer);
          mp4boxfile2.flush();

          initializationSegments.push(initSegs);

          // 動画の秒数を積算（重ねていくわけではなく、連続再生時間）
          // 厳密には計算方法がいろいろありますが、単純化
          totalDuration += (tracks[0] && tracks[0].duration / tracks[0].timescale) || 0;
        }

        // --------------------------------------------------------
        // 2. 実際に MP4 のチャンクを連結
        //    → mp4box.js は、厳密にはトラックの「再生順序」を整理して
        //      コンテナを再パッケージングしています
        // --------------------------------------------------------
        statusText.textContent = "動画を結合しています...";

        // ここでやることは、「連続したストリーム」としてMP4を再生成することですが、
        // mp4box.js のサンプル用途で簡易的に書きます

        // 事前に「トラックが同じコーデックかどうか」などの判定を行うことを推奨
        if (!checkTrackCompatibility(tracks)) {
          throw new Error("動画のコーデックや解像度が一致しないため、結合に失敗する可能性があります。");
        }

        // 非常にシンプルな「連続再生用」の再パッケージの例
        // （実際にはフラグメントごとに書き換えが必要。mp4box.jsはサンプルレベルで簡易実装します）
        let mergedBuffer = null;
        for (let i = 0; i < files.length; i++) {
          // ここでは簡易的に「初期化セグメント + 実データ」を順番に連結
          // → 同一コーデックならプレイヤーによって再生できる可能性がある
          //   ただし汎用的に正常再生できる保証は100%ではありません

          // 初期化セグメントを足す
          for (const segId in initializationSegments[i]) {
            const segAB = initializationSegments[i][segId].buffer;
            mergedBuffer = concatBuffer(mergedBuffer, segAB);
          }

          // 実データ
          const fileAB = await files[i].arrayBuffer();
          mergedBuffer = concatBuffer(mergedBuffer, fileAB);
        }

        if (!mergedBuffer) {
          throw new Error("結合用バッファが作れませんでした。");
        }

        // --------------------------------------------------------
        // 3. Blob化して <video> に表示 & ダウンロードリンク設定
        // --------------------------------------------------------
        const mergedBlob = new Blob([mergedBuffer], { type: "video/mp4" });
        const mergedUrl = URL.createObjectURL(mergedBlob);

        mergedVideo.src = mergedUrl;
        downloadLinkDiv.style.display = "block";

        downloadBtn.onclick = () => {
          const a = document.createElement("a");
          a.href = mergedUrl;
          a.download = "merged_video.mp4";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        };

        statusText.textContent = "結合完了！(コーデックが一致しない場合、再生できない可能性があります)";
      } catch (err) {
        console.error("結合エラー:", err);
        statusText.textContent = "エラー: " + err.message;
        alert("エラーが発生しました: " + err.message);
      } finally {
        mergeButton.disabled = false;
      }
    });

    /**
     * バッファを連結するためのユーティリティ関数
     * @param {ArrayBuffer|null} buffer1
     * @param {ArrayBuffer} buffer2
     * @returns {ArrayBuffer}
     */
    function concatBuffer(buffer1, buffer2) {
      if (!buffer1) return buffer2.slice(0);
      if (!buffer2) return buffer1.slice(0);

      const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
      tmp.set(new Uint8Array(buffer1), 0);
      tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
      return tmp.buffer;
    }

    /**
     * 同一コーデックかどうかを判定する（超簡易版）
     * - 正確には、動画・音声それぞれのsample entryやcodec、ビットレート、解像度などを細かく確認すべき
     * @param {Array} tracks 
     * @returns {boolean} 全トラックの形式が同じならtrue
     */
    function checkTrackCompatibility(tracks) {
      // ここでは簡易的に1つ目のコーデックに全員が一致しているかを見る
      if (tracks.length < 1) return true;
      const firstCodec = tracks[0].codec;
      for (let i = 1; i < tracks.length; i++) {
        if (tracks[i].codec !== firstCodec) {
          return false;
        }
      }
      return true;
    }
  </script>
</body>
</html>
